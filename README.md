# Customer Registration & Email Verification

## Overview
Small Spring Boot app that provides an endpoint to register a customer and perform an asynchronous identity verification with a mock third-party service.

Key features:
- Java 17, Spring Boot, Spring Data JPA (Hibernate)
- In-memory H2 DB
- REST endpoint: `POST /customers`
- Input validation (Jakarta Validation)
- Asynchronous background identity verification that updates `verificationStatus` in the customers table
- Outbound HTTP call to a mock verification service (Postman mock server)
- Support the Github CI workflow

## Requirements
- Java 17+
- Gradle

## Setup
1. Build:
   ```bash
    export EXTERNAL_VERIFICATION_URL=put_correct_mock_server
   ./gradlew build
   ```
2. Run tests:
    ```bash
   ./gradlew test
   ```
## Run with docker
1. Build: 
   ```bash
   docker build -t spring-app .
   ```
2. Run app:
   ```bash
   docker run -p 8080:8080 \
   -e EXTERNAL_VERIFICATION_URL=put_correct_mock_server \
   spring-app
   ```

3. Create new customer:
   ```bash
   curl -X POST http://localhost:8080/customers \
   -u pavlo:abc123 \
   -H "Content-Type: application/json" \
   -d '{
    "firstName": "Pavlo",
    "lastName": "Che",
    "email": "example1@gmail.com"
   }'
   ```
4. Find customer by id
   ```bash
   curl -X GET http://localhost:8080/customers/1 \
   -u pavlo:abc123
   ```

## Room for improvements
1. Normalize the customers table by splitting it into customers and customer_verifications tables:
   ```sql
   CREATE TABLE customers
   (
       id                  BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
       first_name          VARCHAR(256)        NOT NULL,
       last_name           VARCHAR(256)        NOT NULL,
       email               VARCHAR(256) UNIQUE NOT NULL,
   );

    CREATE TABLE customer_verifications (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        customer_id BIGINT NOT NULL,
        status VARCHAR(50) NOT NULL,
        updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (customer_id) REFERENCES customers(id)
    );
    ```
If we need to keep historical verification data (e.g., track how and when the verification status changes), 
itâ€™s a good idea to separate the customers table from the customer_verifications table.

2. Use WebClient for reactive communication with downstream services.
   In our case, the mock server is responsible for email verification, and using WebClient would allow for fully non-blocking, asynchronous calls.

3. Introduce a users table (e.g., with login, role) to support proper authentication and authorization.
   Additionally, consider integrating OAuth2 or JWT tokens for more secure and scalable authentication.
4. Use a mapping library (e.g., MapStruct) to handle entity-to-DTO and DTO-to-entity conversions automatically.
   This improves maintainability and reduces boilerplate code.